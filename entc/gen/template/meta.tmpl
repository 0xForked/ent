{{ define "meta" }}

{{ template "header" $.Package }}

{{ template "import" $ }}

const (
	// Label holds the string label denoting the {{ lower $.Name }} type in the database.
	Label = "{{ $.Label }}"
	{{ range $_, $e := $.Edges }}{{ $label := $e.Constant -}}
		{{ if $e.IsInverse }}{{- $label = $e.InverseConstant -}}
			// {{ $label }} holds the string label denoting the {{ lower $e.Name }} inverse edge type in the database.
		{{ else -}}
			// {{ $label }} holds the string label denoting the {{ lower $e.Name }} edge type in the database.
		{{ end -}}
		{{ $label }} = "{{ $e.Label }}"
	{{ end -}}
	{{ range $_, $f := $.Fields -}}{{ $field := $f.Constant -}}
		// {{ $field }} holds the string denoting the {{ lower $f.Name }} vertex property in the database.
		{{ $field }} = "{{ snake $f.Name }}"
		{{ if $f.HasDefault }}
		{{- $default := $f.DefaultConstant -}}
		// {{ $default }} holds the default value for the {{ $f.Name }} field.
		{{ $default }} {{ if $f.Type.Numeric }} {{ $f.Type }} {{ end }} = {{ printf "%#v" $f.Default }}
		{{ end -}}
	{{ end -}}
	// {{ $.ID.Constant }} holds the string denoting the id field in the database.
	{{ $.ID.Constant }} = "{{ snake $.ID.Name }}"
	// Table holds the table name of the {{ lower $.Name }} in the database.
	Table = "{{ $.Table }}"
	{{- range $_, $e := $.Edges }}
		// {{ $e.TableConstant }} is the table the holds the {{ $e.Name }} relation/edge.
		{{- if $e.M2M }} The primary key declared below.{{ end }}
		{{ $e.TableConstant }} = "{{ $e.Rel.Table }}"
		{{- if eq $.Table $e.Type.Table | not }}
			// {{ $e.InverseTableConstant }} is the table name for the {{ $e.Type.Name }} entity.
			// It exists in this package in order to avoid circular dependency with the "{{ $e.Type.Package }}" package.
			{{ $e.InverseTableConstant }} = "{{ $e.Type.Table }}"
		{{- end }}
		{{- if not $e.M2M }}
			// {{ $e.ColumnConstant }} is the table column denoting the {{ $e.Name }} relation/edge.
			{{ $e.ColumnConstant }} = "{{ $e.Rel.Column }}"
		{{- end }}
	{{- end }}
)

// Columns holds all SQL columns are {{ lower $.Name }} fields.
var Columns = []string{
	{{ $.ID.Constant }},
	{{- range $_, $f := $.Fields }}
		{{ $f.Constant }},
	{{- end }}
}

{{ with $.NumM2M }}
	var (
		{{- range $_, $e := $.Edges }}
			{{- if $e.M2M }}
				// {{ $e.PKConstant }} and {{ $e.ColumnConstant }}2 are the table columns denoting the
				// primary key for the {{ $e.Name }} relation (M2M).
				{{ $e.PKConstant }} = []string{"{{ index $e.Rel.Columns 0 }}", "{{ index $e.Rel.Columns 1 }}"}
			{{- end }}
		{{- end }}
	)
{{ end }}

{{ if $.HasValidators }}
var (
	fields = {{ base $.Schema }}.{{ $.Name }}{}.Fields()
	{{ range $i, $f := $.Fields -}}
		{{ with $f.Validators -}}
			{{ $name := $f.Validator -}}
			{{ $type :=  printf "func (%s) error" $f.Type -}}
			// {{ $name }} is a validator for the "{{ $f.Name }}" field. It is called by the builders before save.
			{{ if eq $f.Validators 1 -}}
				{{ $name }} = fields[{{ $i }}].Validators()[0].({{ $type }})
			{{ else -}}
				{{ $name }} = func() {{ $type }} {
					validators := fields[{{ $i }}].Validators()
					fns := [...]func({{ $f.Type }}) error {
						{{- range $j, $n := xrange $f.Validators }}
							validators[{{ $j }}].(func({{ $f.Type }}) error),
						{{- end }}
					}
					return func({{ $f.Name }} {{ $f.Type }}) error {
						for _, fn := range fns {
							if err := fn({{ $f.Name }}); err != nil {
								return err
							}
						}
						return nil
					}
				}()
			{{ end -}}
		{{ end -}}
	{{ end -}}
)
{{ end }}

{{ end }}